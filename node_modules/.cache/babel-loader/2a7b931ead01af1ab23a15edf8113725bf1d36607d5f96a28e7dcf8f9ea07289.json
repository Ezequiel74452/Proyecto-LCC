{"ast":null,"code":"class PengineClient {\n  static init(callback) {\n    if (!this.instance) {\n      this.instance = new PengineClient();\n    }\n    this.createdPromise.then(() => callback(this.instance));\n  }\n\n  /**\r\n  * handleCreate is the callback for Pengine server creation\r\n  */\n  constructor() {\n    this.queryId = -1;\n    this.queryCallbacks = {};\n    this.query = this.query.bind(this);\n    this.handleSuccess = this.handleSuccess.bind(this);\n    this.pengine = new window.Pengine({\n      server: \"http://localhost:3030/pengine\",\n      application: \"proylcc\",\n      oncreate: PengineClient.handleCreate,\n      onsuccess: this.handleSuccess,\n      onfailure: this.handleFailure,\n      onerror: this.handleError,\n      destroy: false\n    });\n  }\n\n  /**\r\n  * Callback for successful response received from Pengines server.\r\n  */\n\n  handleSuccess(response) {\n    // console.log(response);\n    const queryId = response.data[0][\"QueryId\"];\n    const success = response.data[0][\"Success\"] === 1;\n    if (this.queryCallbacks[queryId]) {\n      this.queryCallbacks[queryId](success, response.data[0], response.more);\n      delete this.queryCallbacks[queryId];\n    }\n  }\n\n  /**\r\n  * Called when the pengine fails to find a solution.\r\n  */\n\n  handleFailure() {\n    console.log(\"Failure\");\n  }\n  handleError(response) {\n    throw response.data;\n  }\n\n  /**\r\n   * Build a prolog query based on input query that:\r\n   *  - tracks an id for the query through a variable QueryId, so it also comes with the response and we can\r\n   *    call the corresponding callback, recorded in queryCallbacks under the id.\r\n   *  - always succeeds so we ensure QueryId is bound, but the success state of the original query is determined \r\n   *    by the value bound to Success variable.\r\n   * @param {*} query \r\n   * @param {*} callback \r\n   */\n\n  query(query, callback) {\n    this.queryId++;\n    this.queryCallbacks[this.queryId] = callback;\n    this.pengine.ask(\"QueryId=\" + this.queryId + \",((\" + query + \", Success = 1) ; Success = 0)\");\n  }\n  next(callback) {\n    this.pengine.next();\n    this.queryCallbacks[this.queryId] = callback;\n  }\n  static stringify(obj) {\n    return window.Pengine.stringify(obj);\n  }\n}\nPengineClient.createdPromise = new Promise(resolve => {\n  PengineClient.handleCreate = resolve;\n});\nexport default PengineClient;","map":{"version":3,"names":["PengineClient","init","callback","instance","createdPromise","then","constructor","queryId","queryCallbacks","query","bind","handleSuccess","pengine","window","Pengine","server","application","oncreate","handleCreate","onsuccess","onfailure","handleFailure","onerror","handleError","destroy","response","data","success","more","console","log","ask","next","stringify","obj","Promise","resolve"],"sources":["C:/Users/ezequ/Desktop/Estudio/UNS/Tercer Año/Primer cuatrimestre/Lógica para ciencias de la computación/Proyecto/Proyecto-LCC/src/PengineClient.js"],"sourcesContent":["class PengineClient {\r\n\r\n    queryId = -1;\r\n    queryCallbacks = {};\r\n\r\n    static instance;\r\n    static handleCreate;\r\n    static createdPromise = new Promise(resolve => {\r\n        this.handleCreate = resolve;        \r\n    });\r\n    static init(callback) {\r\n        if (!this.instance) {\r\n            this.instance = new PengineClient();\r\n        }\r\n        this.createdPromise.then(() => callback(this.instance));\r\n    }\r\n\r\n    /**\r\n    * handleCreate is the callback for Pengine server creation\r\n    */\r\n    constructor() {\r\n        this.query = this.query.bind(this);\r\n        this.handleSuccess = this.handleSuccess.bind(this);\r\n        this.pengine = new window.Pengine({\r\n            server: \"http://localhost:3030/pengine\",\r\n            application: \"proylcc\",\r\n            oncreate: PengineClient.handleCreate,\r\n            onsuccess: this.handleSuccess,\r\n            onfailure: this.handleFailure,\r\n            onerror: this.handleError,\r\n            destroy: false\r\n        });\r\n    }\r\n\r\n    /**\r\n    * Callback for successful response received from Pengines server.\r\n    */\r\n\r\n    handleSuccess(response) {\r\n        // console.log(response);\r\n        const queryId = response.data[0][\"QueryId\"];\r\n        const success = response.data[0][\"Success\"] === 1;\r\n        if (this.queryCallbacks[queryId]) {\r\n            this.queryCallbacks[queryId](success, response.data[0], response.more);\r\n            delete this.queryCallbacks[queryId];\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Called when the pengine fails to find a solution.\r\n    */\r\n\r\n    handleFailure() {\r\n        console.log(\"Failure\");\r\n    }\r\n\r\n    handleError(response) {\r\n        throw response.data;\r\n    }\r\n\r\n    /**\r\n     * Build a prolog query based on input query that:\r\n     *  - tracks an id for the query through a variable QueryId, so it also comes with the response and we can\r\n     *    call the corresponding callback, recorded in queryCallbacks under the id.\r\n     *  - always succeeds so we ensure QueryId is bound, but the success state of the original query is determined \r\n     *    by the value bound to Success variable.\r\n     * @param {*} query \r\n     * @param {*} callback \r\n     */\r\n\r\n    query(query, callback) {\r\n        this.queryId++;\r\n        this.queryCallbacks[this.queryId] = callback;\r\n        this.pengine.ask(\"QueryId=\" + this.queryId + \",((\" + query + \", Success = 1) ; Success = 0)\");\r\n    }\r\n\r\n    next(callback) {\r\n        this.pengine.next();\r\n        this.queryCallbacks[this.queryId] = callback;\r\n    }\r\n\r\n    static stringify(obj) {\r\n        return window.Pengine.stringify(obj);\r\n    }\r\n\r\n}\r\n\r\nexport default PengineClient;"],"mappings":"AAAA,MAAMA,aAAa,CAAC;EAUhB,OAAOC,IAAIA,CAACC,QAAQ,EAAE;IAClB,IAAI,CAAC,IAAI,CAACC,QAAQ,EAAE;MAChB,IAAI,CAACA,QAAQ,GAAG,IAAIH,aAAa,EAAE;IACvC;IACA,IAAI,CAACI,cAAc,CAACC,IAAI,CAAC,MAAMH,QAAQ,CAAC,IAAI,CAACC,QAAQ,CAAC,CAAC;EAC3D;;EAEA;AACJ;AACA;EACIG,WAAWA,CAAA,EAAG;IAAA,KAlBdC,OAAO,GAAG,CAAC,CAAC;IAAA,KACZC,cAAc,GAAG,CAAC,CAAC;IAkBf,IAAI,CAACC,KAAK,GAAG,IAAI,CAACA,KAAK,CAACC,IAAI,CAAC,IAAI,CAAC;IAClC,IAAI,CAACC,aAAa,GAAG,IAAI,CAACA,aAAa,CAACD,IAAI,CAAC,IAAI,CAAC;IAClD,IAAI,CAACE,OAAO,GAAG,IAAIC,MAAM,CAACC,OAAO,CAAC;MAC9BC,MAAM,EAAE,+BAA+B;MACvCC,WAAW,EAAE,SAAS;MACtBC,QAAQ,EAAEjB,aAAa,CAACkB,YAAY;MACpCC,SAAS,EAAE,IAAI,CAACR,aAAa;MAC7BS,SAAS,EAAE,IAAI,CAACC,aAAa;MAC7BC,OAAO,EAAE,IAAI,CAACC,WAAW;MACzBC,OAAO,EAAE;IACb,CAAC,CAAC;EACN;;EAEA;AACJ;AACA;;EAEIb,aAAaA,CAACc,QAAQ,EAAE;IACpB;IACA,MAAMlB,OAAO,GAAGkB,QAAQ,CAACC,IAAI,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;IAC3C,MAAMC,OAAO,GAAGF,QAAQ,CAACC,IAAI,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC;IACjD,IAAI,IAAI,CAAClB,cAAc,CAACD,OAAO,CAAC,EAAE;MAC9B,IAAI,CAACC,cAAc,CAACD,OAAO,CAAC,CAACoB,OAAO,EAAEF,QAAQ,CAACC,IAAI,CAAC,CAAC,CAAC,EAAED,QAAQ,CAACG,IAAI,CAAC;MACtE,OAAO,IAAI,CAACpB,cAAc,CAACD,OAAO,CAAC;IACvC;EACJ;;EAEA;AACJ;AACA;;EAEIc,aAAaA,CAAA,EAAG;IACZQ,OAAO,CAACC,GAAG,CAAC,SAAS,CAAC;EAC1B;EAEAP,WAAWA,CAACE,QAAQ,EAAE;IAClB,MAAMA,QAAQ,CAACC,IAAI;EACvB;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEIjB,KAAKA,CAACA,KAAK,EAAEP,QAAQ,EAAE;IACnB,IAAI,CAACK,OAAO,EAAE;IACd,IAAI,CAACC,cAAc,CAAC,IAAI,CAACD,OAAO,CAAC,GAAGL,QAAQ;IAC5C,IAAI,CAACU,OAAO,CAACmB,GAAG,CAAC,UAAU,GAAG,IAAI,CAACxB,OAAO,GAAG,KAAK,GAAGE,KAAK,GAAG,+BAA+B,CAAC;EACjG;EAEAuB,IAAIA,CAAC9B,QAAQ,EAAE;IACX,IAAI,CAACU,OAAO,CAACoB,IAAI,EAAE;IACnB,IAAI,CAACxB,cAAc,CAAC,IAAI,CAACD,OAAO,CAAC,GAAGL,QAAQ;EAChD;EAEA,OAAO+B,SAASA,CAACC,GAAG,EAAE;IAClB,OAAOrB,MAAM,CAACC,OAAO,CAACmB,SAAS,CAACC,GAAG,CAAC;EACxC;AAEJ;AArFMlC,aAAa,CAORI,cAAc,GAAG,IAAI+B,OAAO,CAACC,OAAO,IAAI;EAP7CpC,aAAa,CAQNkB,YAAY,GAAGkB,OAAO;AAC/B,CAAC,CAAC;AA8EN,eAAepC,aAAa"},"metadata":{},"sourceType":"module","externalDependencies":[]}